//! Trading actions
//!
//! Defines the actions that can be taken by the state machine.

use serde::{Deserialize, Serialize};

/// Trading action
///
/// Represents an action to be executed by the state machine.
/// These are typically generated by strategies and executed by the state machine.
///
/// # Examples
///
/// ```
/// use trading_engine::state_machine::{Action, action::Side};
///
/// let action = Action::EnterLong {
///     price: 50000.0,
///     quantity: 0.1,
/// };
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Action {
    /// Enter a long position
    EnterLong {
        price: f64,
        quantity: f64,
    },

    /// Enter a short position
    EnterShort {
        price: f64,
        quantity: f64,
    },

    /// Exit the current position
    ExitPosition {
        price: f64,
    },

    /// Update stop loss
    UpdateStopLoss {
        new_stop: f64,
    },

    /// Update take profit
    UpdateTakeProfit {
        new_target: f64,
    },

    /// Transition to Analyzing state (opportunity detected)
    StartAnalyzing {
        reason: String,
    },

    /// Cancel analysis and return to Idle
    CancelAnalysis {
        reason: String,
    },

    /// Do nothing
    NoAction,
}

/// Position side (Long or Short)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Side {
    /// Long position (buy to profit from price increase)
    Long,

    /// Short position (sell to profit from price decrease)
    Short,
}

impl Side {
    /// Check if this is a long position
    pub fn is_long(&self) -> bool {
        matches!(self, Side::Long)
    }

    /// Check if this is a short position
    pub fn is_short(&self) -> bool {
        matches!(self, Side::Short)
    }
}

impl std::fmt::Display for Side {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Side::Long => write!(f, "Long"),
            Side::Short => write!(f, "Short"),
        }
    }
}

impl Action {
    /// Check if this action enters a position
    pub fn is_entry(&self) -> bool {
        matches!(self, Action::EnterLong { .. } | Action::EnterShort { .. })
    }

    /// Check if this action exits a position
    pub fn is_exit(&self) -> bool {
        matches!(self, Action::ExitPosition { .. })
    }

    /// Check if this action modifies an existing position
    pub fn is_modification(&self) -> bool {
        matches!(
            self,
            Action::UpdateStopLoss { .. } | Action::UpdateTakeProfit { .. }
        )
    }

    /// Get the side for entry actions
    pub fn entry_side(&self) -> Option<Side> {
        match self {
            Action::EnterLong { .. } => Some(Side::Long),
            Action::EnterShort { .. } => Some(Side::Short),
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_action_checks() {
        let enter_long = Action::EnterLong {
            price: 50000.0,
            quantity: 0.1,
        };
        assert!(enter_long.is_entry());
        assert!(!enter_long.is_exit());
        assert_eq!(enter_long.entry_side(), Some(Side::Long));

        let exit = Action::ExitPosition { price: 51000.0 };
        assert!(exit.is_exit());
        assert!(!exit.is_entry());

        let update_stop = Action::UpdateStopLoss { new_stop: 49000.0 };
        assert!(update_stop.is_modification());
        assert!(!update_stop.is_entry());
    }

    #[test]
    fn test_side() {
        assert!(Side::Long.is_long());
        assert!(!Side::Long.is_short());
        assert!(Side::Short.is_short());
        assert!(!Side::Short.is_long());
    }

    #[test]
    fn test_side_display() {
        assert_eq!(format!("{}", Side::Long), "Long");
        assert_eq!(format!("{}", Side::Short), "Short");
    }
}
